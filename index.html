<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Jenga Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #resetBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.3);
        }

        #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 36, 0.4);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255,255,255,0.3);
        }

        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        #gameOver button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        #gameOver button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(68, 160, 141, 0.4);
        }

        .control-item {
            margin: 5px 0;
            font-size: 14px;
        }

        .highlight {
            color: #4ecdc4;
            font-weight: bold;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>Blocks Removed: <span id="score">0</span></div>
            <div>Status: <span id="status">Ready to Play</span></div>
        </div>

        <div id="controls">
            <div class="control-item"><span class="highlight">Left Mouse:</span> Rotate camera</div>
            <div class="control-item"><span class="highlight">Right Mouse:</span> Pan camera</div>
            <div class="control-item"><span class="highlight">Wheel:</span> Zoom in/out</div>
            <div class="control-item"><span class="highlight">Click Block:</span> Select block</div>
            <div class="control-item"><span class="highlight">WASD:</span> Move selected block</div>
            <div class="control-item"><span class="highlight">Space/Ctrl:</span> Up/Down</div>
            <div class="control-item"><span class="highlight">X:</span> Drop block</div>
        </div>

        <button id="resetBtn">Reset Game</button>

        <div id="gameOver">
            <h2>Tower Collapsed!</h2>
            <p>You removed <span id="finalScore">0</span> blocks</p>
            <p>Great job! The tower couldn't hold any longer.</p>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/TransformControls.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, world;
        let jengaBlocks = [];
        let selectedBlock = null;
        let transformControls;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        
        // Keyboard controls
        let keys = {
            w: false, a: false, s: false, d: false,
            space: false, ctrl: false, x: false
        };
        let cameraControls = {
            isRotating: false,
            isPanning: false,
            previousMouse: { x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            distance: 15,
            target: new THREE.Vector3(0, 8, 0)
        };
        let gameState = {
            score: 0,
            isGameOver: false,
            removedBlocks: 0
        };

        // Physics simulation variables
        let physicsWorld = {
            gravity: -9.82,
            blocks: [],
            timeStep: 1/60
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Add lighting
            setupLighting();

            // Create ground
            createGround();

            // Setup transform controls for block movement visualization
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setMode('translate');
            transformControls.enabled = false;
            transformControls.visible = false;
            scene.add(transformControls);

            // Build Jenga tower
            buildJengaTower();

            // Setup event listeners
            setupEventListeners();

            // Start render loop
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            scene.add(directionalLight);

            // Fill light
            const fillLight = new THREE.DirectionalLight(0x4ecdc4, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a5998,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function buildJengaTower() {
            const blockGeometry = new THREE.BoxGeometry(0.75, 0.25, 2.25);
            const blockMaterials = [
                new THREE.MeshPhongMaterial({ color: 0xDEB887 }),
                new THREE.MeshPhongMaterial({ color: 0xD2B48C }),
                new THREE.MeshPhongMaterial({ color: 0xCD853F }),
                new THREE.MeshPhongMaterial({ color: 0xF5DEB3 })
            ];

            jengaBlocks = [];
            physicsWorld.blocks = [];

            for (let level = 0; level < 18; level++) {
                const y = 0.125 + level * 0.25;
                const isEvenLevel = level % 2 === 0;
                
                for (let i = 0; i < 3; i++) {
                    const block = new THREE.Mesh(blockGeometry, blockMaterials[Math.floor(Math.random() * blockMaterials.length)]);
                    
                    if (isEvenLevel) {
                        block.position.set((i - 1) * 0.75, y, 0);
                    } else {
                        block.position.set(0, y, (i - 1) * 0.75);
                        block.rotation.y = Math.PI / 2;
                    }

                    block.castShadow = true;
                    block.receiveShadow = true;
                    block.userData = {
                        id: jengaBlocks.length,
                        level: level,
                        position: i,
                        originalPosition: block.position.clone(),
                        originalRotation: block.rotation.clone(),
                        velocity: new THREE.Vector3(0, 0, 0),
                        isRemoved: false,
                        isStable: true
                    };

                    scene.add(block);
                    jengaBlocks.push(block);

                    // Add to physics world
                    physicsWorld.blocks.push({
                        mesh: block,
                        velocity: new THREE.Vector3(0, 0, 0),
                        acceleration: new THREE.Vector3(0, 0, 0),
                        mass: 1,
                        isStatic: false,
                        isGrounded: false
                    });
                }
            }
        }

        function setupEventListeners() {
            const canvas = renderer.domElement;

            // Mouse events
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('click', onMouseClick);

            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // UI events
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Prevent context menu
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Make canvas focusable for keyboard events
            canvas.setAttribute('tabindex', '0');
            canvas.focus();
        }

        function onMouseDown(event) {
            event.preventDefault();
            
            if (event.button === 0) { // Left mouse button - camera rotation
                cameraControls.isRotating = true;
                cameraControls.previousMouse.x = event.clientX;
                cameraControls.previousMouse.y = event.clientY;
            } else if (event.button === 2) { // Right mouse button - camera panning
                cameraControls.isPanning = true;
                cameraControls.previousMouse.x = event.clientX;
                cameraControls.previousMouse.y = event.clientY;
            }
        }

        function onMouseClick(event) {
            event.preventDefault();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(jengaBlocks.filter(block => !block.userData.isRemoved));

            if (intersects.length > 0 && !gameState.isGameOver) {
                // Deselect previous block
                if (selectedBlock) {
                    returnBlockToPosition(selectedBlock);
                }

                // Select new block
                selectedBlock = intersects[0].object;
                selectedBlock.material.emissive.setHex(0x444444);
                selectedBlock.userData.currentOffset = new THREE.Vector3(0, 0, 0);
                transformControls.attach(selectedBlock);
                transformControls.visible = true;
                document.getElementById('status').textContent = 'Block Selected - Use WASD to move';
            } else if (selectedBlock) {
                // Deselect if clicking empty space
                returnBlockToPosition(selectedBlock);
            }
        }

        function onMouseMove(event) {
            event.preventDefault();

            if (cameraControls.isRotating) {
                // Camera rotation
                const deltaX = event.clientX - cameraControls.previousMouse.x;
                const deltaY = event.clientY - cameraControls.previousMouse.y;

                cameraControls.rotation.y -= deltaX * 0.01;
                cameraControls.rotation.x -= deltaY * 0.01;
                cameraControls.rotation.x = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, cameraControls.rotation.x));

                updateCameraPosition();

                cameraControls.previousMouse.x = event.clientX;
                cameraControls.previousMouse.y = event.clientY;
                
            } else if (cameraControls.isPanning) {
                // Camera panning
                const deltaX = event.clientX - cameraControls.previousMouse.x;
                const deltaY = event.clientY - cameraControls.previousMouse.y;

                const panSpeed = 0.01;
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                
                camera.getWorldDirection(new THREE.Vector3());
                right.setFromMatrixColumn(camera.matrix, 0);
                up.setFromMatrixColumn(camera.matrix, 1);
                
                right.multiplyScalar(-deltaX * panSpeed * cameraControls.distance * 0.1);
                up.multiplyScalar(deltaY * panSpeed * cameraControls.distance * 0.1);
                
                cameraControls.target.add(right).add(up);
                
                cameraControls.target.x = THREE.MathUtils.clamp(cameraControls.target.x, -10, 10);
                cameraControls.target.y = THREE.MathUtils.clamp(cameraControls.target.y, 2, 15);
                cameraControls.target.z = THREE.MathUtils.clamp(cameraControls.target.z, -10, 10);
                
                updateCameraPosition();

                cameraControls.previousMouse.x = event.clientX;
                cameraControls.previousMouse.y = event.clientY;
            }
        }

        function onMouseUp(event) {
            cameraControls.isRotating = false;
            cameraControls.isPanning = false;
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            
            switch(key) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': 
                    event.preventDefault(); 
                    keys.space = true; 
                    break;
                case 'control': keys.ctrl = true; break;
                case 'x': 
                    keys.x = true;
                    if (selectedBlock) {
                        dropBlock(selectedBlock);
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            
            switch(key) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'control': keys.ctrl = false; break;
                case 'x': keys.x = false; break;
            }
        }

        function onMouseWheel(event) {
            event.preventDefault();
            cameraControls.distance += event.deltaY * 0.01;
            cameraControls.distance = Math.max(8, Math.min(25, cameraControls.distance));
            updateCameraPosition();
        }

        function checkCollision(block) {
            const blockBox = new THREE.Box3().setFromObject(block);
            for (const otherBlock of jengaBlocks) {
                if (otherBlock !== block && !otherBlock.userData.isRemoved) {
                    const otherBox = new THREE.Box3().setFromObject(otherBlock);
                    if (blockBox.intersectsBox(otherBox)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateBlockMovement() {
            if (!selectedBlock || selectedBlock.userData.isRemoved || gameState.isGameOver) return;

            const moveSpeed = 0.02; // Base movement speed
            const fastSpeed = 0.05; // Speed when holding keys longer
            const maxOffset = 2.5; // Maximum distance from original position

            if (!selectedBlock.userData.currentOffset) {
                selectedBlock.userData.currentOffset = new THREE.Vector3(0, 0, 0);
            }

            let moved = false;
            const currentOffset = selectedBlock.userData.currentOffset;
            const previousOffset = currentOffset.clone();

            // WASD movement
            if (keys.w) {
                currentOffset.z -= moveSpeed;
                moved = true;
            }
            if (keys.s) {
                currentOffset.z += moveSpeed;
                moved = true;
            }
            if (keys.a) {
                currentOffset.x -= moveSpeed;
                moved = true;
            }
            if (keys.d) {
                currentOffset.x += moveSpeed;
                moved = true;
            }

            // Vertical movement
            if (keys.space) {
                currentOffset.y += moveSpeed * 0.5;
                moved = true;
            }
            if (keys.ctrl) {
                currentOffset.y -= moveSpeed * 0.5;
                moved = true;
            }

            // Clamp offsets to maximum distances
            currentOffset.x = THREE.MathUtils.clamp(currentOffset.x, -maxOffset, maxOffset);
            currentOffset.y = THREE.MathUtils.clamp(currentOffset.y, -0.5, 1.0);
            currentOffset.z = THREE.MathUtils.clamp(currentOffset.z, -maxOffset, maxOffset);

            // Apply movement
            if (moved) {
                selectedBlock.position.copy(selectedBlock.userData.originalPosition).add(currentOffset);
                // Prevent clipping with other blocks
                if (checkCollision(selectedBlock)) {
                    currentOffset.copy(previousOffset);
                    selectedBlock.position.copy(selectedBlock.userData.originalPosition).add(currentOffset);
                }
                // Player retains control; block will not fall until dropped
            }
        }

        function dropBlock(block) {
            if (!block || block.userData.isRemoved) return;

            const distance = block.userData.currentOffset ? block.userData.currentOffset.length() : 0;

            if (distance > 0.8) {
                block.material.emissive.setHex(0x000000);
                removeBlock(block);
                transformControls.detach();
                transformControls.visible = false;
                selectedBlock = null;
                document.getElementById('status').textContent = 'Ready to Play';
            } else {
                // Return to original position
                returnBlockToPosition(block);
            }
        }

        function returnBlockToPosition(block) {
            if (!block) return;

            block.material.emissive.setHex(0x000000);
            block.position.copy(block.userData.originalPosition);
            block.userData.currentOffset = new THREE.Vector3(0, 0, 0);
            transformControls.detach();
            transformControls.visible = false;
            selectedBlock = null;
            document.getElementById('status').textContent = 'Ready to Play';
        }

        function removeBlock(block) {
            if (block.userData.isRemoved) return;

            block.userData.isRemoved = true;
            gameState.score++;
            gameState.removedBlocks++;
            
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('status').textContent = 'Block Removed!';

            // Animate block removal in the direction it was pulled
            let direction = new THREE.Vector3(0, -1, 0);
            if (block.userData.currentOffset && block.userData.currentOffset.length() > 0) {
                direction = block.userData.currentOffset.clone().normalize();
                direction.y = -0.5; // Always fall down
            }
            
            const targetPosition = block.position.clone().add(direction.multiplyScalar(8));
            targetPosition.y -= 4;

            animateBlockRemoval(block, targetPosition);

            // Deselect the block
            selectedBlock = null;

            // Check stability after a short delay
            setTimeout(() => {
                checkTowerStability();
            }, 1000);
        }

        function animateBlockReturn(block) {
            const startPosition = block.position.clone();
            const targetPosition = block.userData.originalPosition.clone();
            const duration = 300;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic

                block.position.lerpVectors(startPosition, targetPosition, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function animateBlockRemoval(block, targetPosition) {
            const startPosition = block.position.clone();
            const startRotation = block.rotation.clone();
            const duration = 1000;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                block.position.lerpVectors(startPosition, targetPosition, easeProgress);
                block.rotation.x = startRotation.x + easeProgress * Math.PI * 2;
                block.rotation.z = startRotation.z + easeProgress * Math.PI;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(block);
                    const index = jengaBlocks.indexOf(block);
                    if (index > -1) {
                        jengaBlocks.splice(index, 1);
                    }
                }
            }

            animate();
        }

        function checkTowerStability() {
            let unstableBlocks = 0;
            
            jengaBlocks.forEach(block => {
                if (!block.userData.isRemoved) {
                    const physicsBlock = physicsWorld.blocks.find(pb => pb.mesh === block);
                    if (physicsBlock) {
                        // Apply physics simulation
                        simulateBlockPhysics(physicsBlock);
                        
                        // Check if block has moved significantly
                        if (block.position.distanceTo(block.userData.originalPosition) > 0.5) {
                            unstableBlocks++;
                        }
                    }
                }
            });

            if (unstableBlocks > 3) {
                setTimeout(() => {
                    gameOver();
                }, 2000);
            }
        }

        function simulateBlockPhysics(physicsBlock) {
            const block = physicsBlock.mesh;

            // Skip physics for the block currently being controlled by the player
            if (block.userData.isRemoved || block === selectedBlock) return;

            // Apply simple gravity
            physicsBlock.velocity.y += physicsWorld.gravity * physicsWorld.timeStep;
            block.position.y += physicsBlock.velocity.y * physicsWorld.timeStep;

            // Ground collision
            if (block.position.y <= 0.125) {
                block.position.y = 0.125;
                physicsBlock.velocity.y = 0;
            }

            // Collision with other blocks
            const blockBox = new THREE.Box3().setFromObject(block);
            jengaBlocks.forEach(otherBlock => {
                if (otherBlock !== block && !otherBlock.userData.isRemoved) {
                    const otherBox = new THREE.Box3().setFromObject(otherBlock);
                    if (blockBox.intersectsBox(otherBox) && block.position.y > otherBlock.position.y) {
                        block.position.y = otherBox.max.y + 0.125;
                        physicsBlock.velocity.y = 0;
                    }
                }
            });
        }

        function updateCameraPosition() {
            const x = cameraControls.distance * Math.sin(cameraControls.rotation.y) * Math.cos(cameraControls.rotation.x);
            const y = cameraControls.distance * Math.sin(cameraControls.rotation.x) + cameraControls.target.y;
            const z = cameraControls.distance * Math.cos(cameraControls.rotation.y) * Math.cos(cameraControls.rotation.x);

            camera.position.set(x, y, z);
            camera.lookAt(cameraControls.target);
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('status').textContent = 'Game Over';
        }

        function resetGame() {
            // Clear existing blocks
            jengaBlocks.forEach(block => {
                scene.remove(block);
            });

            // Reset game state
            gameState = {
                score: 0,
                isGameOver: false,
                removedBlocks: 0
            };

            selectedBlock = null;
            isDragging = false;

            // Reset UI
            document.getElementById('score').textContent = '0';
            document.getElementById('status').textContent = 'Ready to Play';
            document.getElementById('gameOver').style.display = 'none';

            // Reset camera
            cameraControls.rotation = { x: 0, y: 0 };
            cameraControls.distance = 15;
            updateCameraPosition();

            // Rebuild tower
            buildJengaTower();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update physics for all blocks
            physicsWorld.blocks.forEach(physicsBlock => {
                if (!gameState.isGameOver) {
                    simulateBlockPhysics(physicsBlock);
                }
            });

            // Update movement for the currently selected block
            updateBlockMovement();

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
